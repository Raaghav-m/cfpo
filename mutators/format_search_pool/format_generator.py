"""
LLM-Guided Format Generator

Uses an LLM to generate NEW format templates at runtime.
This is the key innovation from CFPO - dynamically expanding
the format search space.
"""

import re
import logging
from typing import Optional, Dict, Any, Tuple, Callable, List
from dataclasses import dataclass, field


@dataclass
class GeneratedFormat:
    """A format generated by the LLM."""
    name: str
    description: str
    render_code: str
    extract_code: str
    render_fn: Optional[Callable] = None
    extract_fn: Optional[Callable] = None
    is_valid: bool = False
    error: Optional[str] = None


class LLMFormatGenerator:
    """
    Generates new format templates using an LLM.
    
    The LLM proposes new formats based on:
    1. The current task and prompt
    2. Existing formats in the pool
    3. Performance history
    """
    
    def __init__(self, llm, task, logger: Optional[logging.Logger] = None):
        """
        Initialize the format generator.
        
        Args:
            llm: The LLM model to use for generation
            task: The current task
            logger: Optional logger
        """
        self.llm = llm
        self.task = task
        self.logger = logger or logging.getLogger(__name__)
        self.generated_formats: Dict[str, GeneratedFormat] = {}
        self.generation_count = 0
    
    def generate_prompt_renderer(self, current_prompt, existing_formats: List[str]) -> Optional[GeneratedFormat]:
        """
        Generate a new prompt renderer format.
        
        Args:
            current_prompt: The current prompt being optimized
            existing_formats: List of existing format names
            
        Returns:
            GeneratedFormat if successful, None otherwise
        """
        format_list = ", ".join(existing_formats[:5])
        
        meta_prompt = f"""I'm creating prompts for: {self.task.task_intention if hasattr(self.task, 'task_intention') else 'a reasoning task'}

Current prompt structure:
- TASK_INSTRUCTION: {current_prompt.task_instruction[:100]}...
- TASK_DETAIL: {current_prompt.task_detail[:100]}...
- OUTPUT_FORMAT: {current_prompt.output_format[:100]}...

Existing formats: {format_list}

Please generate ONE new prompt format that is different from the existing ones.
The format should be clear, structured, and suitable for AI prompts.

Requirements:
1. Use consistent formatting (headers, markers, etc.)
2. Include all components: TASK_INSTRUCTION, TASK_DETAIL, OUTPUT_FORMAT, EXAMPLES
3. The format name should use only alphanumeric characters and underscores

Respond with:
<FORMAT>
<NAME>format_name</NAME>
<DESCRIPTION>Brief description of the format</DESCRIPTION>
<TEMPLATE>
[Show how the format renders the components using {{TASK_INSTRUCTION}}, {{TASK_DETAIL}}, {{OUTPUT_FORMAT}}, {{EXAMPLES}}, {{COT_HINTER}} placeholders]
</TEMPLATE>
</FORMAT>
"""
        
        try:
            response = self.llm.generate(meta_prompt, temperature=0.9)
            return self._parse_generated_format(response, 'prompt_renderer')
        except Exception as e:
            self.logger.error(f"Error generating prompt renderer: {e}")
            return None
    
    def generate_query_format(self, current_prompt, task_type: str = 'qa') -> Optional[GeneratedFormat]:
        """
        Generate a new query format for Q&A or multiple choice.
        
        Args:
            current_prompt: The current prompt
            task_type: 'qa' or 'multiple_choice'
            
        Returns:
            GeneratedFormat if successful, None otherwise
        """
        if task_type == 'multiple_choice':
            example = """Question: What is 2+2?
A) 3  B) 4  C) 5  D) 6
Answer: B"""
        else:
            example = """Q: John has 5 apples. He buys 3 more. How many?
A: 5 + 3 = 8. The answer is: 8"""
        
        meta_prompt = f"""I need a new format for presenting questions and answers.
Task type: {task_type}

Example in plain format:
{example}

Please generate ONE new Q&A format that is different from standard formats.
Consider variations in:
- CASING: Title case, UPPERCASE, lowercase, or different wording
- SEPARATORS: Different punctuation or symbols (e.g., --, ::, ||, â†’)
- STRUCTURE: Order of elements, spacing, indentation

Respond with:
<QUERY_FORMAT>
<NAME>format_name</NAME>
<DESCRIPTION>Brief description</DESCRIPTION>
<EXAMPLE>
[Show an example using the new format]
</EXAMPLE>
</QUERY_FORMAT>
"""
        
        try:
            response = self.llm.generate(meta_prompt, temperature=0.9)
            return self._parse_generated_format(response, 'query_format')
        except Exception as e:
            self.logger.error(f"Error generating query format: {e}")
            return None
    
    def generate_format_code(self, generated_format: GeneratedFormat, format_type: str = 'prompt_renderer') -> GeneratedFormat:
        """
        Generate Python code for a format template.
        
        Args:
            generated_format: The format specification
            format_type: 'prompt_renderer' or 'query_format'
            
        Returns:
            Updated GeneratedFormat with code
        """
        if format_type == 'prompt_renderer':
            code_prompt = f"""Generate Python code for a prompt renderer.

Format name: {generated_format.name}
Description: {generated_format.description}

Generate two functions:
1. {generated_format.name}_renderer(prompt) -> str
   - Takes a prompt object with: task_instruction, task_detail, output_format, examples, cot_hinter
   - Returns the formatted string

2. {generated_format.name}_extractor(text) -> dict
   - Takes a text string
   - Returns a dict with keys: task_instruction, task_detail, output_format, examples

Respond with ONLY the Python code, no markdown:
def {generated_format.name}_renderer(prompt):
    ...

def {generated_format.name}_extractor(text):
    ...
"""
        else:
            code_prompt = f"""Generate Python code for a query format.

Format name: {generated_format.name}
Description: {generated_format.description}

Generate two functions:
1. {generated_format.name}_renderer(question, answer, cot_hinter="") -> str
   - Formats a question-answer pair
   - Returns the formatted string

2. {generated_format.name}_extractor(response) -> tuple
   - Takes a response string
   - Returns (extracted_answer, full_response)

Respond with ONLY the Python code, no markdown:
def {generated_format.name}_renderer(question, answer, cot_hinter=""):
    ...

def {generated_format.name}_extractor(response):
    ...
"""
        
        try:
            response = self.llm.generate(code_prompt, temperature=0.3)
            
            # Clean the response
            code = self._clean_code(response)
            
            # Try to compile and execute the code
            namespace = {}
            try:
                exec(code, namespace)
                
                renderer_fn = namespace.get(f"{generated_format.name}_renderer")
                extractor_fn = namespace.get(f"{generated_format.name}_extractor")
                
                if callable(renderer_fn) and callable(extractor_fn):
                    generated_format.render_code = code
                    generated_format.render_fn = renderer_fn
                    generated_format.extract_fn = extractor_fn
                    generated_format.is_valid = True
                else:
                    generated_format.error = "Generated functions are not callable"
                    
            except SyntaxError as e:
                generated_format.error = f"Syntax error: {e}"
            except Exception as e:
                generated_format.error = f"Execution error: {e}"
                
        except Exception as e:
            generated_format.error = f"Generation error: {e}"
        
        return generated_format
    
    def _parse_generated_format(self, response: str, format_type: str) -> Optional[GeneratedFormat]:
        """Parse LLM response to extract format specification."""
        try:
            if format_type == 'prompt_renderer':
                name_match = re.search(r'<NAME>(.*?)</NAME>', response, re.DOTALL)
                desc_match = re.search(r'<DESCRIPTION>(.*?)</DESCRIPTION>', response, re.DOTALL)
                template_match = re.search(r'<TEMPLATE>(.*?)</TEMPLATE>', response, re.DOTALL)
                
                if name_match and desc_match:
                    name = self._clean_name(name_match.group(1).strip())
                    description = desc_match.group(1).strip()
                    template = template_match.group(1).strip() if template_match else ""
                    
                    self.generation_count += 1
                    return GeneratedFormat(
                        name=name,
                        description=description,
                        render_code=template,
                        extract_code="",
                    )
            else:
                name_match = re.search(r'<NAME>(.*?)</NAME>', response, re.DOTALL)
                desc_match = re.search(r'<DESCRIPTION>(.*?)</DESCRIPTION>', response, re.DOTALL)
                example_match = re.search(r'<EXAMPLE>(.*?)</EXAMPLE>', response, re.DOTALL)
                
                if name_match and desc_match:
                    name = self._clean_name(name_match.group(1).strip())
                    description = desc_match.group(1).strip()
                    example = example_match.group(1).strip() if example_match else ""
                    
                    self.generation_count += 1
                    return GeneratedFormat(
                        name=name,
                        description=description,
                        render_code=example,
                        extract_code="",
                    )
                    
        except Exception as e:
            self.logger.error(f"Error parsing format: {e}")
        
        return None
    
    def _clean_name(self, name: str) -> str:
        """Clean format name to be valid Python identifier."""
        # Remove special characters
        name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure starts with letter
        if name and name[0].isdigit():
            name = 'format_' + name
        # Add unique suffix
        name = f"{name}_{self.generation_count}"
        return name.lower()
    
    def _clean_code(self, code: str) -> str:
        """Clean generated code."""
        # Remove markdown code blocks
        code = re.sub(r'^```python\s*', '', code)
        code = re.sub(r'^```\s*', '', code)
        code = re.sub(r'\s*```$', '', code)
        
        # Remove language identifiers
        lines = code.split('\n')
        if lines and lines[0].strip() in ['python', 'py']:
            lines = lines[1:]
        
        return '\n'.join(lines)
    
    def add_generated_format(self, format_obj: GeneratedFormat) -> bool:
        """Add a validated generated format to the pool."""
        if format_obj.is_valid:
            self.generated_formats[format_obj.name] = format_obj
            self.logger.info(f"Added generated format: {format_obj.name}")
            return True
        return False
    
    def get_generated_formats(self) -> Dict[str, GeneratedFormat]:
        """Get all successfully generated formats."""
        return {k: v for k, v in self.generated_formats.items() if v.is_valid}
    
    def get_all_renderers(self) -> Dict[str, Tuple[Callable, Callable]]:
        """Get all generated renderer/extractor pairs."""
        return {
            name: (fmt.render_fn, fmt.extract_fn)
            for name, fmt in self.generated_formats.items()
            if fmt.is_valid and fmt.render_fn and fmt.extract_fn
        }
